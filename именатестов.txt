{unit-of-work} _ {scenario} _ {expected-results-or-behaviour}

Где: unit-of-work - это как раз то что Вы понимаете под 'unit' или о чем договорились с командой. scenario - это конкретное действие над тестируемым объектом expected-results-or-behaviour - это Ваши ожидания относительно того, что должно произойти

Примеры:

    jsonParse_InvalidFileExtension_ThrowInvalidLogFileException

Сразу видно, что проверяется парсер json-документа на файле с недопустимым файловым расширением и поэтому должно быть брошено InvalidLogFileException.

    opimizeByteCode_UnknownInstruction_ReturnMinusOne

Тут видно, что при оптимизации байт-кода будет возвращаться -1 в случае если встретится неизвестная инструкция.

Распространенные шаблоны наименования такие:

    TestClass_TestMethod_ConditionAndExpectedResult (для юнит-тестов)
    TestMethod_Condition_ExpectedResult (для юнит-тестов)
    ConditionAndExpectedResult (для интеграционных тестов, которые тестируют целые блоки функциональности через некоторую входную точку)

При этом если у вас в частях Condition/ExpectedResult слишком много разных условий/результатов, объединенных по "И", то вам нужно пересмотреть либо главную цель теста (что он тестирует), либо главное условие, которое отличает тест от других, и разбить его на несколько отдельных тестов.

Если кратко, то в одном модульном тесте ОДНА проверка. Если условие сложно, значит там несколько под условий и значит надо Взять и разбить на несколько проверок - модульных тестов
В любом тесте не должно быть условной логики. Если в production-коде есть две ветки, одна if-часть, другая else-часть. Значит пишется ДВА модульных теста.